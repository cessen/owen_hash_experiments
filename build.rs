// Copyright (c) 2012 Leonhard Gruenschloss (leonhard@gruenschloss.org)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Adapted from Python to Rust and to generate Rust instead of C by Nathan Vegdahl

// Generate Rust code for evaluating Halton points with Faure-permutations for different bases.

use std::{env, fs::File, io::Write, path::Path};

/// What file to generate the sobol numbers from.
const DIRECTION_NUMBERS_TEXT: &str = include_str!("direction_numbers/new-joe-kuo-5.1024.txt");
// const DIRECTION_NUMBERS_TEXT: &str = include_str!("direction_numbers/joe-kuo-other-3.1024.txt");
// const DIRECTION_NUMBERS_TEXT: &str = include_str!("direction_numbers/new-joe-kuo-6.1024.txt");

/// How many components to generate.
const NUM_DIMENSIONS: usize = 128;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();

    //------------------------------------
    // Sobol
    let dest_path = Path::new(&out_dir).join("vectors.inc");
    let mut f = File::create(&dest_path).unwrap();

    // Init direction vectors.
    let vectors = generate_direction_vectors(NUM_DIMENSIONS);

    // Write dimensions limit.
    f.write_all(format!("pub const MAX_DIMENSION: u32 = {};\n", NUM_DIMENSIONS).as_bytes())
        .unwrap();

    // Write the vectors.
    f.write_all(format!("pub const VECTORS: &[[u{0}; {0}]] = &[\n", SOBOL_BITS).as_bytes())
        .unwrap();
    for v in vectors.iter() {
        f.write_all("  [\n".as_bytes()).unwrap();
        for n in v.iter() {
            f.write_all(format!("    0x{:04x},\n", *n).as_bytes())
                .unwrap();
        }
        f.write_all("  ],\n".as_bytes()).unwrap();
    }
    f.write_all("];\n".as_bytes()).unwrap();

    // ---------------------------------------
    // Halton
    let dest_path = Path::new(&out_dir).join("halton.rs");
    let mut f = File::create(&dest_path).unwrap();

    // Init prime number array.
    let primes = {
        let mut primes = Vec::new();
        let mut candidate = 1;
        for _ in 0..NUM_DIMENSIONS {
            loop {
                candidate += 1;
                if is_prime(candidate) {
                    primes.push(candidate);
                    break;
                }
            }
        }
        primes
    };

    // Init Faure permutations.
    let faure = {
        let mut faure: Vec<Vec<usize>> = Vec::new();
        for b in 0..(primes.last().unwrap() + 1) {
            let perm = get_faure_permutation(&faure, b);
            faure.push(perm);
        }
        faure
    };

    // Write the beginning bits of the file
    f.write_all(
        format!(
            r#"
// Copyright (c) 2012 Leonhard Gruenschloss (leonhard@gruenschloss.org)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This file is automatically generated.

// Compute points of the Halton sequence with with Faure-permutations for different bases.

pub const MAX_DIMENSION: u32 = {};
"#,
            NUM_DIMENSIONS
        )
        .as_bytes(),
    )
    .unwrap();

    // Write the sampling function
    f.write_all(
        format!(
            r#"
pub fn sample(dimension: u32, index: u32) -> f32 {{
    let mut index = index;

    match dimension {{"#
        )
        .as_bytes(),
    )
    .unwrap();

    // Write the special-cased first dimension
    f.write_all(
        format!(
            r#"
        // Special case: radical inverse in base 2, with direct bit reversal.
        0 => {{
            index = (index << 16) | (index >> 16);
            index = ((index & 0x00ff00ff) << 8) | ((index & 0xff00ff00) >> 8);
            index = ((index & 0x0f0f0f0f) << 4) | ((index & 0xf0f0f0f0) >> 4);
            index = ((index & 0x33333333) << 2) | ((index & 0xcccccccc) >> 2);
            index = ((index & 0x55555555) << 1) | ((index & 0xaaaaaaaa) >> 1);
            return (index as f32) * (1.0 / ((1u64 << 32) as f32));
        }}"#,
        )
        .as_bytes(),
    )
    .unwrap();

    // The rest of the dimensions.
    for i in 1..NUM_DIMENSIONS {
        let base = primes[i];

        // Based on the permutation table size, we process multiple digits at once.
        let mut digits = 1;
        let mut pow_base = base;
        while pow_base * base <= 500 {
            // Maximum permutation table size.
            pow_base *= base;
            digits += 1;
        }

        let mut max_power = pow_base;
        let mut powers = Vec::new();
        while (max_power * pow_base) < (1 << 32) {
            // 32-bit unsigned precision
            powers.push(max_power);
            max_power *= pow_base;
        }

        // Build the permutation table.
        let perm = (0..pow_base)
            .map(|j| invert(&faure, base, j, digits))
            .collect::<Vec<_>>();
        let perm_string = {
            let mut perm_string = String::new();
            for i in perm.iter() {
                let s = format!("{}, ", i);
                perm_string.push_str(&s);
            }
            perm_string
        };

        let mut power = max_power / pow_base;
        f.write_all(
            format!(
                r#"

        {} => {{
            static PERM{}: [u16; {}] = [{}];"#,
                i,
                base,
                perm.len(),
                perm_string
            )
            .as_bytes(),
        )
        .unwrap();

        f.write_all(
            format!(
                r#"
            return unsafe {{(
                *PERM{}.get_unchecked((index % {}) as usize) as u32 * {}"#,
                base, pow_base, power
            )
            .as_bytes(),
        )
        .unwrap();

        // Advance to next set of digits.
        let mut div = 1;
        while power / pow_base > 1 {
            div *= pow_base;
            power /= pow_base;
            f.write_all(
                format!(
                    r#"
                + *PERM{}.get_unchecked(((index / {}) % {}) as usize) as u32 * {}"#,
                    base, div, pow_base, power
                )
                .as_bytes(),
            )
            .unwrap();
        }

        f.write_all(
            format!(
                r#"
                + *PERM{}.get_unchecked(((index / {}) % {}) as usize) as u32
            )}} as f32
            * (0.999999940395355224609375f32 / ({}u32 as f32)); // Results in [0,1).
        }}
        "#,
                base,
                div * pow_base,
                pow_base,
                max_power
            )
            .as_bytes(),
        )
        .unwrap();
    }

    f.write_all(
        format!(
            r#"
        _ => panic!("Halton sampling: exceeded max dimensions."),
    }}
}}
    "#
        )
        .as_bytes(),
    )
    .unwrap();
}

/// Check primality. Not optimized, since it's not performance-critical.
fn is_prime(p: usize) -> bool {
    for i in 2..p {
        if (p % i) == 0 {
            return false;
        }
    }
    return true;
}

/// Computes the Faure digit permutation for 0, ..., b - 1.
fn get_faure_permutation(faure: &Vec<Vec<usize>>, b: usize) -> Vec<usize> {
    if b < 2 {
        return vec![0];
    } else if b == 2 {
        return vec![0, 1];
    } else if (b & 1) != 0 {
        // odd
        let c = (b - 1) / 2;

        return (0..b)
            .map(|i| {
                if i == c {
                    return c;
                }

                let f: usize = faure[b - 1][i - ((i > c) as usize)];
                f + ((f >= c) as usize)
            })
            .collect();
    } else {
        // even
        let c = b / 2;

        return (0..b)
            .map(|i| {
                if i < c {
                    2 * faure[c][i]
                } else {
                    2 * faure[c][i - c] + 1
                }
            })
            .collect();
    }
}

/// Compute the radical inverse with Faure permutations.
fn invert(faure: &Vec<Vec<usize>>, base: usize, mut index: usize, digits: usize) -> usize {
    let mut result = 0;
    for _ in 0..digits {
        let remainder = index % base;
        index = index / base;
        result = result * base + faure[base][remainder];
    }
    return result;
}

//======================================================================

// The following is adapted from the code on this webpage:
//
// http://web.maths.unsw.edu.au/~fkuo/sobol/
//
// From these papers:
//
//     * S. Joe and F. Y. Kuo, Remark on Algorithm 659: Implementing Sobol's
//       quasirandom sequence generator, ACM Trans. Math. Softw. 29,
//       49-57 (2003)
//
//     * S. Joe and F. Y. Kuo, Constructing Sobol sequences with better
//       two-dimensional projections, SIAM J. Sci. Comput. 30, 2635-2654 (2008)
//
// The adapted code is under the following license:
//
//     Copyright (c) 2008, Frances Y. Kuo and Stephen Joe
//     All rights reserved.
//
//     Redistribution and use in source and binary forms, with or without
//     modification, are permitted provided that the following conditions are
//     met:
//
//       * Redistributions of source code must retain the above copyright
//         notice, this list of conditions and the following disclaimer.
//
//       * Redistributions in binary form must reproduce the above copyright
//         notice, this list of conditions and the following disclaimer in the
//         documentation and/or other materials provided with the
//         distribution.
//
//       * Neither the names of the copyright holders nor the names of the
//         University of New South Wales and the University of Waikato
//         and its contributors may be used to endorse or promote products
//         derived from this software without specific prior written
//         permission.
//
//     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
//     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE
//     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
//     BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
//     WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
//     OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
//     IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

type SobolInt = u16;
const SOBOL_BITS: usize = std::mem::size_of::<SobolInt>() * 8;

pub fn generate_direction_vectors(dimensions: usize) -> Vec<[SobolInt; SOBOL_BITS]> {
    let mut vectors = Vec::new();

    // Calculate first dimension, which is just the van der Corput sequence.
    let mut dim_0 = [0 as SobolInt; SOBOL_BITS];
    for i in 0..SOBOL_BITS {
        dim_0[i] = 1 << (SOBOL_BITS - 1 - i);
    }
    vectors.push(dim_0);

    // Do the rest of the dimensions.
    let mut lines = DIRECTION_NUMBERS_TEXT.lines();
    for _ in 1..dimensions {
        let mut v = [0 as SobolInt; SOBOL_BITS];

        // Get data from the next valid line from the direction numbers text
        // file.
        let (s, a, m) = loop {
            if let Ok((a, m)) = parse_direction_numbers(
                lines
                    .next()
                    .expect("Not enough direction numbers for the requested number of dimensions."),
            ) {
                break (m.len(), a, m);
            }
        };

        // Generate the direction numbers for this dimension.
        if SOBOL_BITS <= s as usize {
            for i in 0..SOBOL_BITS {
                v[i] = (m[i] << (SOBOL_BITS - 1 - i)) as SobolInt;
            }
        } else {
            for i in 0..(s as usize) {
                v[i] = (m[i] << (SOBOL_BITS - 1 - i)) as SobolInt;
            }

            for i in (s as usize)..SOBOL_BITS {
                v[i] = v[i - s as usize] ^ (v[i - s as usize] >> s);

                for k in 1..s {
                    v[i] ^= ((a >> (s - 1 - k)) & 1) as SobolInt * v[i - k as usize];
                }
            }
        }

        vectors.push(v);
    }

    vectors
}

#[derive(Debug, Copy, Clone)]
struct ParseError(());
impl std::error::Error for ParseError {}
impl std::fmt::Display for ParseError {
    fn fmt(&self, _f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {
        Ok(())
    }
}

/// Parses the direction numbers from a single line of the direction numbers
/// text file.  Returns the `a` and `m` parts.
fn parse_direction_numbers(text: &str) -> Result<(u32, Vec<u32>), Box<dyn std::error::Error>> {
    let mut numbers = text.split_whitespace();
    if numbers.clone().count() < 4 || text.starts_with("#") {
        return Err(Box::new(ParseError(())));
    }

    // Skip the first two numbers, which are just the dimension and the count
    // of direction numbers for this dimension.
    let _ = numbers.next().unwrap().parse::<u32>()?;
    let _ = numbers.next().unwrap().parse::<u32>()?;

    let a = numbers.next().unwrap().parse::<u32>()?;

    let mut m = Vec::new();
    for n in numbers {
        m.push(n.parse::<u32>()?);
    }

    Ok((a, m))
}
